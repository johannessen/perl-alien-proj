use 5.010;
use alienfile;
use Sort::Versions;
use Path::Tiny qw /path/;


my $on_windows = $^O =~ /mswin/i;
my $on_automated_rig
  =  $ENV{PERL_CPAN_REPORTER_DIR}
  || $ENV{PERL_CPAN_REPORTER_CONFIG}
  || $ENV{AUTOMATED_TESTING}
  || $ENV{TRAVIS}
  || $ENV{APPVEYOR}
  || $ENV{CI};


use Cwd;
my $base_dir = getcwd();

use Env qw( @PATH @PKG_CONFIG_PATH );

use Alien::sqlite;
unshift @PATH, Alien::sqlite->bin_dir;
my @dep_aliens = ('Alien::sqlite');
my %have;
my $lib = 'Alien::curl';
$have{$lib} = eval "require $lib";
if ($have{$lib}) {
    unshift @PATH, $lib->dist_dir . '/dynamic';
}
$lib = 'Alien::libtiff';
$have{$lib} = eval "require $lib";
if ($have{$lib}) {
    #say 'Adding libtiff dependency';
    unshift @PATH, $lib->bin_dir;
    push @dep_aliens, $lib;
    if ($on_windows) { # && $lib->install_type eq 'system') {
      #  dirty hack for strawberry perl
      my $p = path ($^X)->parent->parent->parent . '/c/lib/pkgconfig';
      if (-e $p) {
        push @PKG_CONFIG_PATH, $p;
      }
    }
}

#  see if this helps with cirrus bsd builds
$ENV{SQLITE3_CFLAGS} = Alien::sqlite->cflags;
$ENV{SQLITE3_LIBS} = Alien::sqlite->libs;

say "Alien::sqlite has sqlite version " . Alien::sqlite->version;
#say "sqlite cflags: " . Alien::sqlite->cflags;
#say "sqlite libs: " . Alien::sqlite->libs; 

plugin 'Build::SearchDep' => (
  aliens   => [ @dep_aliens ],
  public_I => 1,
  public_l => 1,
);

my $min_target_version = '4.9.0';

plugin 'PkgConfig' => (
    pkg_name => 'proj',
    minimum_version => $min_target_version,
);


share {

  my $with_local = '';
  my $with_cpp11 = '';

  start_url 'http://download.osgeo.org/proj/';
  #start_url "file://$base_dir";  #  debug
  plugin Download => (
    filter  => qr/^proj-([0-9\.]+)\.tar\.gz$/,
    version => qr/^proj-([0-9\.]+)\.tar\.gz$/,
  );

  my $proj_version = get_proj_version() // 'not yet defined';
  say "Downloaded proj version is $proj_version";
  
  plugin Extract => (format => 'tar.gz');


  plugin 'Build::Autoconf' => ();

  my $build_static = $on_windows ? '' : '--disable-shared';
  $build_static = '';
  $build_static = '--enable-static=no';  #  override - needed?  leftover from gdal
  $build_static = '' if $ENV{FORCE_DYNAMIC};
  
  
  if ($^O =~ /bsd/) {
    plugin 'Build::Make' => 'gmake';
    if (!-e '/usr/local/include/sqlite3.h' && Alien::sqlite->install_type eq 'system') {
      warn '/usr/local/include/sqlite3.h does not exist, '
         . 'you might need to install the sqlite package for your system, '
         . 'or install a share version of Alien::sqlite';
    }
  }
  elsif ($^O =~ /dragonfly/) {
    #  might need to be combined with bsd check above
    #  but not sure if /usr/local is needed yet
    plugin 'Build::Make' => 'gmake';
  }

  my $make_cmd = '%{make}';
  my $make_inst_cmd = '%{make} install';
  my @make_clean;
  #  try not to exceed the cpan-testers log limits
  if ($on_automated_rig) {
    say "Running under CI or automated testing";
    $make_cmd      .= q/ | perl -ne "BEGIN {$|=1; open our $log, q|>|, q|build.log|};   print qq|\n| if 0 == ($. %% 100); print q|.|; print {$log} $_;" || type build.log/;
    $make_inst_cmd .= q/ | perl -ne "BEGIN {$|=1; open our $log, q|>|, q|install.log|}; print qq|\n| if 0 == ($. %% 100); print q|.|; print {$log} $_;" || type install.log/;
    if (!$on_windows) {
        $make_cmd =~ s/%%/%/;
        $make_cmd =~ s/type/cat/;
        $make_cmd =~ s/"/'/g;
        $make_inst_cmd =~ s/%%/%/;
        $make_inst_cmd =~ s/type/cat/;
        $make_inst_cmd =~ s/"/'/g;
    }
    #if (! ($ENV{TRAVIS} || $ENV{APPVEYOR})) {
    #    push @make_clean, '%{make} clean';
    #}
    #  clean up the build dir on cpan testers etc
    #  but not github workflows
    if (!$ENV{CI}) {
      plugin 'Cleanse::BuildDir';
    }
  }
  
  my $config_args = $ENV{ALIEN_PROJ_CONFIG_ARGS} // '';
  $config_args =~ s/[^-\s\w,=]//g;  #  overkill?
  my $with_tiff = '';  #  only needed for proj 7+
  my $with_curl = '';  #  only needed for proj 7+
  if ($proj_version ge 7) {
    if (!$have{'Alien::libtiff'}) {
      $with_tiff = '--disable-tiff';  
    }
    else {
      $with_tiff = '--enable-tiff';
    }
    if (!$have{'Alien::curl'}) {
      $with_curl = '--without-curl';
    }
    else {
      my $dynamic_config = path ('Alien::curl'->dist_dir . '/dynamic/curl-config');
      if (-e $dynamic_config) {
        say 'Adding curl support';
        $with_curl = "--with-curl=$dynamic_config";
      }
      elsif ('Alien::curl'->install_type eq 'system') {
        if ('Alien::curl'->cflags =~ /STATIC_LIB/) {
          $with_curl = '--without-curl';
          say 'Disabling curl support.  You have Alien::curl, but it lacks a dynamic curl-config.';
        }
        else {
          say 'Adding curl support';
          $with_curl = '--with_curl=yes';
        }
      }
      else {
        say 'Disabling curl support.  You have Alien::curl, but it lacks a dynamic curl-config.';
        #  until we depend on an Alien::libcurl that provides a dynamic curl-config
        $with_curl = '--without-curl';  
      }
    }
  }
  $config_args = "$with_local $with_cpp11 $with_tiff $with_curl $build_static $config_args";

  meta->around_hook( build => \&set_pkgconf_shim );
  
  build [
    #\&pause,
    #\&update_pkg_conf_path,
    "%{configure} $config_args",
    $make_cmd,
    $make_inst_cmd,
    #@make_clean,
    \&rename_la_files,
  ];

};

#gather [
#    \&rename_la_files,
#];
#

sub set_pkgconf_shim {
  my $orig = shift;
  my $build = shift;

  $orig->($build, @_)
    if !$on_windows;
  
  use File::Which qw /which/;
  use Path::Tiny qw /path/;

  my @found = which $ENV{PKG_CONFIG}
           || which 'ppkg-config'
           || which 'pkg-config.pl'
           || which 'pkg-config';


  die "Could not locate ppkg-config or pkg-config in your path:\n"
     . join '', $ENV{PATH}
    if !@found;
  
  my $pk = $found[0];
  
  if ($pk =~ /\.bat$/i) {
    $pk =~ s/\.bat$//i;
    die "bat file does not have adjacent pkg-config"
      if !-e $pk;
  }
  
  my $data = path($pk)->slurp;

  #  flaky  
  my $str = <<"EOSTRING"
# lightweight no-dependency version of pkg-config. This will work on any machine
# with Perl installed.
EOSTRING
  ;

  my $fname;  
  if ($data =~ /$str/msi) {
    #say 'found pure perl pkg-config';
    my $perl = $^X;
    $perl =~ s/\.exe$//i;
    foreach my $path ($perl, $pk) {
      $path =~ s{\\}{/}g;
      $path =~ s{^([a-z]):/}{/$1/}i;
    }
    my $args = '$' . join ' $', (1..9);
    
    my $shim = <<"EOSHIM"
#/bin/sh

$perl $pk $args
EOSHIM
  ;
    say "Pure perl pkg-config detected on windows.";
    say "Wrapping $pk in shell script to cope with MSYS perl and paths.";
    $fname = path($build->root, 'pkg-config');
    open my $fh, '>', $fname
      or die "Unable to open pkg-config wrapper $fname, $!";
    print {$fh} $shim;
    close ($fh);
    say "Setting \$ENV{PKG_CONFIG} to point to $fname"; 
  }
  
  local $ENV{PKG_CONFIG} = $fname
    if $fname;

  $orig->($build, @_);
}

sub update_pkg_conf_path {
  $ENV{PKG_CONFIG_PATH} = 'C:\berrybrew\5.28.2_64_PDL\c\lib\pkgconfig;C:\berrybrew\5.30.0_64_PDL\c\lib\pkgconfig';
  $ENV{PKG_CONFIG} = 'C:\berrybrew\5.28.0_64_PDL\data\pkg-config';
  return;
    return if !$on_windows;
    #  should be a before or around hook
    use Env qw /@PKG_CONFIG_PATH/;
    say 'Modifying drive paths in PKG_CONFIG_PATH';
    say $ENV{PKG_CONFIG_PATH};
    #  msys-ificate drive paths
    @PKG_CONFIG_PATH = map {s{^([a-z]):}{/$1}ri} @PKG_CONFIG_PATH;
    #  make sure we get the dynamic libcurl
    #  (although the proj configure script does not currently use it)
    @PKG_CONFIG_PATH
      = map {s{Alien-curl[/\\]lib[/\\]pkgconfig}{Alien-curl/dynamic/pkgconfig}ri}
        @PKG_CONFIG_PATH;
    $ENV{PKG_CONFIG_PATH} = join ':', @PKG_CONFIG_PATH;
    say $ENV{PKG_CONFIG_PATH};
    return;
}

sub rename_la_files {
    #  need to return if not share
    return if !$on_windows;
    
    use File::Find::Rule;
    my @la_files
      = File::Find::Rule->file()
                        ->name( '*.la' )
                        ->in( $base_dir );
    foreach my $file (@la_files) {
        say "Renaming $file so it will not interfere with gdal compilation";
        rename $file, $file . '.bak';
    }

}


sub pause {
    #return;  #  re-enable in case of debug
    return if $on_automated_rig;
    return if !$on_windows;

    say "CONTINUE?";
    my $response = <>;
    while (not $response =~ /yes/) {
        $response = <>;
    }
}


sub get_proj_version {
    my $h = get_alien_state_hash();
    return $h->{runtime}{version};
}

sub get_alien_state_hash {
    use JSON::PP;
    my $root = "$base_dir/_alien";
    my $f = "$root/state.json";
    my $h = {};
    if (-e $f) {
        open my $fh, '<', $f or die $!;
        my $d = do {
            local $/ = undef;
            <$fh>;
        };
        $h = JSON::PP::decode_json($d);
    }
    return $h;
}

